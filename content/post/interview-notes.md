---
title: 面试笔记整理
date: 2019-07-08 20:14:17
lastmod: 2019-08-29
categories: ['Notes']
tags: ['interview']
mathjax: true

---

总结一下这几个月的面试经历中被问到的问题，虽说问得都很浅，但是，问深了我也不会呀！

## C++相关

Q: `std::vector` push_back 的复杂度是多少？
A: O(1), amortized constant.

Q: vector从1到n push n个元素，假设发生扩容时按两倍增长，写出复杂度关于n的表达式？
A: 不会。

假设第一次只分配一个元素的空间。那么发生扩容的点依次如下：
$$
1,2,4,8,16,..., 2^{\lfloor{\log_2 n}\rfloor}
$$
每次扩容都会copy之前内存中的所有元素，所以总共发生的拷贝次数为:
$$
1+2+4+\cdots+2^{\lfloor{\log_2 n}\rfloor}
$$
注意这里共有$\lfloor \log_2 n \rfloor$项相加，于是有
$$
1+2+4+\cdots+2^{\lfloor{\log_2 n}\rfloor} = O(\lfloor \log_2 n \rfloor \cdot
2^{\lfloor{\log_2 n}\rfloor}) = O(n\log n)
$$
加上push_back操作的次数n，所以有
$$
T(n) = O(n\log n + n) = O(n \log n)
$$

Q: 对于一个vector容器，删除元素后迭代器会失效吗？
A: 对于删除给定元素前的迭代器不会失效，被删除元素之后的迭代器全部失效。

> 向容器添加元素后：
> 
> - 如果容器是vector或string，且存储空间重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。
> - 对于deque，插入到除首尾元素以外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在元素的指针和引用不会失效。
> - 对于list和forward_list，指向容器的迭代器（包括尾后迭代器和首前迭代）、指针和引用都有效。
> 
> 当我们从一个容器中删除元素后，指向被删除元素的迭代器、指针和引用会失效，这应该不会令人惊讶。毕竟，这些元素已经被销毁了。当我们删除一个元素后：
> 
> - 对于list和forward_list，指向容器其他位置的迭代器（包括尾后和首前）、引用和指针仍有效。
> - 对于deque，如果在首尾之外的任何位置删除元素指向被删除元素外其他元素的迭代器、引用和指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。
> - 对于vector和string，指向被删除元素之前的元素迭代器、引用和指针仍有效。注意：当我们删除元素时，尾后迭代器总是会失效。
> <div style="text-align:right">──《C++ Primer》</div>

关于迭代器失效的问题，另参阅：https://blog.csdn.net/lujiandong1/article/details/49872763

Q: 对于使用hash函数组织的unordered_map，对于给定的hash函数，假设我总能构造一个集合，使得该集合内所有元素的hash值相同，即该集合内所有的key都映射到一个桶内。这种问题该如何解决？
A: 不会。

可以使用两个hash函数，例如h1和h2，然后将同一个key的hash值用某种方式连接起来，以此定义一个新的复杂hash函数。对于这个函数，碰撞的概率将会非常小，因此可以认为你设计不出这样的集合，使得集合内的元素都发生碰撞。

Q: new/delete和malloc/free有什么区别？
A: new/delete在C++中是运算符，但malloc/free是继承自C的内存管理函数。malloc只负责开辟指定大小的内存，并不负责初始化，而new及开辟内存，也会构造对象，如果要为自定义的类型申请动态内存，则必须使用new，new一个类型会调用该类型的构造函数。而delete和free的区别也是类似，delete调用类的析构函数，然后在释放内存，free仅释放内存。

Q: 以下调用哪个函数？
```c++
class base {
public:
    virtual void fun(int a) { cout << a << endl; }
};

class derived : public base {
public:
    void fun(int b) { cout << "derived" << endl; }
};

base* pb = new derived();
pb->fun(3);
```
A: derived. 虚函数的动态绑定，根据运行时类型调用对应的版本，虽然是基类指针，但实际上是派生类对象，所以调用派生类中的函数。动态绑定是C++支持多态的根本原因。关于动态绑定，参见：[here](https://www.learncpp.com/cpp-tutorial/122-virtual-functions/). 

另外，定义虚函数会增加空间开销，一旦定义了虚函数，就会生成虚函数表和虚指针，动态绑定实际上是通过查表来确定具体调用哪个版本的函数。另外构造函数不能声明为虚函数，析构函数可以，但析构函数不能声明为纯虚函数。

Q: 重载（overload）和重写（override）有什么区别？
A: 重载指函数签名（函数原型）不同的两个函数名字相同，重写是指子类覆盖（重写）基类的方法，签名必须相同。注意，返回值不算函数签名，const算重载！

另外，还涉及到隐藏的概念。所谓隐藏，其实就是子作用域如果出现和父作用域相同的名字，那么父作用域的该名字在子作用域下被隐藏，不可见，因为被子作用域同名覆盖掉了。派生类的成员将隐藏基类同名成员。请看下例：
```c++
#include <iostream>

using namespace std;

class Base {
public:
    virtual void f(int x) { cout << "Base::f(int)" << endl; }
    void g(float x) { cout << "Base::g(float)" << endl; }
};

class Derived : public Base {
public:
    void f(float x) { cout << "Derived::f(float)" << endl; }
    void g(float x) { cout << "Derived::g(float)" << endl; }
    void g(int x) { cout << "Derived::g(int)" << endl; }
};

// test
int main()
{
    Derived dobj;
    Base* pd = &dobj;
    pd->f(3);       // Base::f(int)
    pd->g(3.3f);    // Base::g(float)
    dobj.f(3.3f);   // Derived::f(float)
    dobj.g(3.3f);   // Derived::g(float)
    dobj.g(3);      // Derived::g(int)
    return 0;
}
```
子类中g发生了重载。而基类指针调用f时，发现是虚函数，会去查表（发生动态绑定），但子类中并没有相应的重写（override），子类中的f仅仅是另一个函数，所以查表得知还是调用基类的f; 基类指针调用g时，发现不是虚函数，直接调用基类的g. 此间，子类的两个g对基类的g都是隐藏！


Q：memcpy 和 memmove 的区别
A：memcpy不能应对内存重叠，memmove可以。详见man pages.

## 算法相关

Q: 从一个数组中删除一个元素，复杂度是多少？如果不关心索引和值的对应关系。
A: O(1), 将要删除的元素与最后一个元素互换，将数组的长度减一。

注意：这里他说不关心数组的索引和值的对应关系。连续存储就是数组，只不过先前通过索引i获得的值，并不一定和删除后通过索引i获得的值相同。我答的是O(n),因为要删除一个元素，还得将删除元素之后的元素前移一位，这样才是我理解的删除的语义。但是面试官说不关心索引与值的对应关系，那么假设数组长度为n，删除元素位置为i，在互换A[i]和A[n]之后，删除后数组的A[i]变成了原先的A[n], 但一般认为删除后A[i]应该是原先的A[i+1], 这就是他说的不关心索引和值的对应，和我所理解的不一样。

Q: 生成50个[0, 50)间的随机整数，构成一个序列，要求不能重复？
A: 用一个长度为50的数组用作map，初始化全为0. 然后使用随机数发生器生成[0, 50)之间的整数，并在map对应索引位置+1. 依次生成随机整数，且判断其索引对应的值是否为0，等于0说明还未生成过，等于1说明已经生成过，应该换一个。但是这样不能保证收敛，也许它永远生成不满50个随机整数。

其实有O(n)的解法，延承自上一问。设有一副扑克牌，共50张，你怎样将它随机地分给排成一列的50个人？很简单，每次随机抽出一张给一个人，抽完了，也就分完了。现在你有一个随机数发生器，每次随机生成一个索引，你抽出该索引位置的牌（从数组中删除该元素），这个操作等价与将该索引的元素与数组最后一个元素互换。下一次，从[0, 49)里随机生成一个索引，纵然该索引与之前的可能一样，但对应位置的牌已经换了，所以不会抽出重复的牌。如此反复，抽完为止。这样你每删除一个元素的复杂度是O(1), 所以总共的复杂度就是O(n).

## 机器学习相关

Q: K-均值聚类中k如何选取，评价指标，他很不稳定，如何让它稳定一些。

评价指标：类间相似度低，类内相似度高。K-means的稳定性较差，可能每次随机选取的初始聚类中心不一样，而导致聚类的效果不一样。从某种程度上来说，K-means对数据较为敏感，无法识别离群点。传统聚类采用的距离度量通常为欧式距离，Kernel k-means将所有样本映射到另外一个特征空间中再进行聚类，就有可能改善聚类效果。

一种改进：K-means++，它的思想是在已经选定n个聚类中心后，选取第n+1个聚类中心时：距离当前n个聚类中心越远的点会有更高的概率被选为第n+1个聚类中心。在选取第一个聚类中心时同样使用随机的方法，这个改单简单有效。

另外，一个很重要的问题，K的值如何选取？在低维度时，可以将数据画出来看大致有几个类，而在面对高维和复杂数据时，这种方法难以使用。关于K的选取：ISODATA，迭代自组织数据分析法，它的思想是：当属与某个类别的样本数量过少时就把该类别去除；当属与某个类别的样本数量过多时，分散程度较大时，将该类别分裂为两个子类。

Q: 正则化如何克服过拟合？背后的原理是什么？

正则化控制模型的复杂度。正则系数越大，模型拟合能力越差（偏差大，方差小），复杂度越低，一定程度上克服了过拟合。考虑正则系数从小变大，一开始偏差较小，方差较大。因为模型足够复杂，可以很好的学到数据特征，但也容易过拟合，对特定的数据集很敏感，也许换一个数据集就会是不一样的结果，此时已经发生了过拟合。随着正则系数不断变大，偏差也跟着增加，但方差会随之减小，因为正则项事实上限制了模型的拟合能力，降低了模型的复杂度。牺牲了偏差（变大），换取了方差（变小）。而在有限的训练数据集上，方差过大就意味着过拟合，意味着模型对数据集敏感。这不是我们想要的。整个过程的泛化误差先减小（方差减小）后增大（偏差增大），先是方差主导，后是偏差主导。最佳的正则系数应该对应着最小的泛化误差。详见PRML p.151

Q: 有没有接触过其他的网络模型，CNN，RNN等？

没有。

Q: vae是生成网络吗？可不可以和infogan结合？了解一下vae？

是。

## 纽劢面经

1. random forest 需要对特征做什么处理吗？
2. 常用的特征选择方法有哪些？
3. 主成分分析做特征选择有哪些缺点？
4. l1 regularization 也可以做特征选择？
5. 特征有离散有连续该怎么处理？ one-hot encoding

## 小米面经

Q: 了解LRU缓存吗？
A: 没听说过。

这里说的缓存是一种广义的概念，在计算机存储层次结构中，低一层的存储器都可以看做是高一层的缓存。比如Cache是内存的缓存，内存是硬盘的缓存，硬盘是网络的缓存等等。

缓存可以有效地解决存储器性能与容量的这对矛盾，但绝非看上去那么简单。如果缓存算法设计不当，非但不能提高访问速度，反而会使系统变得更慢。

从本质上来说，缓存之所以有效是因为程序和数据的局部性（locality）。程序会按固定的顺序执行，数据会存放在连续的内存空间并反复读写。这些特点使得我们可以缓存那些经常用到的数据，从而提高读写速度。

缓存的大小是固定的，它应该只保存最常被访问的那些数据。然而未来不可预知，我们只能从过去的访问序列做预测，于是就有了各种各样的缓存替换策略。本文介绍一种简单的缓存策略，称为最近最少使用（LRU，Least Recently Used）算法。

Q: https加密方式？
A: 不知道啊。

Q: 输入网址到浏览器展示的过程？
A: 不知道。

HTTP的工作流程大致如下：

1. 地址解析
2. 封装HTTP请求。将访问信息以及本机的一些信息封装成一个HTTP请求数据包
3. 封装TCP包。建立 TCP 连接 , 也就是常说的"三次握手" . 由于HTTP位于最上层的应用层 , 所以HTTP在工作之前要由 TCP 和 IP 协议建立网络连接。
4. 客户端发送请求命令。在连接建立之后 , 客户端发送 HTTP 请求到服务端与请求相关的信息都会包含在请求头和请求体中发送给服务器端 .
5. 服务端响应。服务器端在收到请求之后 , 根据客户端的请求发送给客户端相应的信息 , 相关的响应信息都会放在响应头和响应体中 .
6. 关闭连接。服务器端在发送完响应之后 , 就会关闭连接 , 如果过客户端的请求的头部信息中有 `Connection: keep-alive` , 那么客户端在响应完这个请求之后不会关闭连接 , 知道客户端的所有请求都响应完毕 , 才会关闭连接 , 这样大大节省了带宽和 IO 资源 .

**又**

- 自我介绍，实习工作内容
- 局部静态对象和全局静态对象有什么区别
- 进程间通信的方式
- 有哪些同步原语
- 堆内存和栈内存的区别
- `int a, *b;`有什么区别？（考察指针默认不开辟内存）

## 牛客网C++笔记

原地址：https://www.nowcoder.com/discuss/164721?type=0&order=0&pos=16&page=0

Q：说一下static关键字的作用？
A：static可以用来声明静态变量或函数。静态变量存储在静态内存中。直到程序结束才被释放。一般程序有三块内存：静态内存、动态内存（堆内存）、栈内存（局部变量）。需要注意的是，即使在函数内部声明的静态变量，也是放在静态内存中的，静态变量具有静态生命周期。static可用于修饰类的成员。具体作用如下：类的静态成员独立与对象而存在，即便没有对象（类的实例），静态成员依然存在。可以这么想，类的静态成员本质上跟类没啥关系，只是包装在类的作用域下，可能有语义的关联。

Q：说说C++和C的区别？
A：C++ = C + Object-Oriented C + Template + STL.

Q：说说C++中四种强制转换？
A：`static_cast<target type>(variable)`可以将变量强制转化为目标类型；`const_cast<type>(variable)`可以给变量底层强制加上/抹除const属性；`dynamic_cast<type>(variable)`可以做运行时转换，其中一个用处就是在语义正确的前提下，将父类对象的指针或引用转换成子类对象的指针或引用；`reinterpret_cast<type>(variable)`没了解过，据说很危险，不到万不得已千万别用。

Q：怎么判断一个数是二的倍数，怎么求一个数中有几个1，说一下你的思路并手写代码？
A：(x & 1)可以判断奇偶，(x & x-1)可以去掉二进制最低位的1. (c.f. 我的另一篇文章"a collection of coding problems").
